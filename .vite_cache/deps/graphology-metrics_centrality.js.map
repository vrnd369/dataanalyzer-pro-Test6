{
  "version": 3,
  "sources": ["../../node_modules/graphology-metrics/centrality/degree.js", "../../node_modules/obliterator/support.js", "../../node_modules/obliterator/foreach.js", "../../node_modules/mnemonist/utils/typed-arrays.js", "../../node_modules/mnemonist/utils/iterables.js", "../../node_modules/obliterator/iterator.js", "../../node_modules/mnemonist/fixed-deque.js", "../../node_modules/mnemonist/fixed-stack.js", "../../node_modules/mnemonist/utils/comparators.js", "../../node_modules/mnemonist/heap.js", "../../node_modules/graphology-utils/getters.js", "../../node_modules/graphology-indices/neighborhood.js", "../../node_modules/graphology-shortest-path/indexed-brandes.js", "../../node_modules/graphology-utils/defaults.js", "../../node_modules/graphology-metrics/centrality/betweenness.js", "../../node_modules/graphology-metrics/centrality/edge-betweenness.js", "../../node_modules/mnemonist/sparse-set.js", "../../node_modules/graphology-metrics/centrality/closeness.js", "../../node_modules/graphology-metrics/centrality/eigenvector.js", "../../node_modules/graphology-metrics/centrality/hits.js", "../../node_modules/graphology-metrics/centrality/pagerank.js", "../../node_modules/graphology-metrics/centrality/index.js"],
  "sourcesContent": ["/**\n * Graphology Degree Centrality\n * =============================\n *\n * Function computing degree centrality.\n */\nvar isGraph = require('graphology-utils/is-graph');\n\n/**\n * Asbtract function to perform any kind of degree centrality.\n *\n * Intuitively, the degree centrality of a node is the fraction of nodes it\n * is connected to.\n *\n * @param  {boolean} assign           - Whether to assign the result to the nodes.\n * @param  {string}  method           - Method of the graph to get the degree.\n * @param  {Graph}   graph            - A graphology instance.\n * @param  {object}  [options]        - Options:\n * @param  {string}    [nodeCentralityAttribute] - Name of the attribute to assign.\n * @return {object|void}\n */\nfunction abstractDegreeCentrality(assign, method, graph, options) {\n  var name = method + 'Centrality';\n\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-centrality/' +\n        name +\n        ': the given graph is not a valid graphology instance.'\n    );\n\n  if (method !== 'degree' && graph.type === 'undirected')\n    throw new Error(\n      'graphology-centrality/' +\n        name +\n        ': cannot compute ' +\n        method +\n        ' centrality on an undirected graph.'\n    );\n\n  // Solving options\n  options = options || {};\n\n  var centralityAttribute = options.nodeCentralityAttribute || name;\n\n  var ratio = graph.order - 1;\n  var getDegree = graph[method].bind(graph);\n\n  if (assign) {\n    graph.updateEachNodeAttributes(\n      function (node, attr) {\n        attr[centralityAttribute] = getDegree(node) / ratio;\n        return attr;\n      },\n      {attributes: [centralityAttribute]}\n    );\n\n    return;\n  }\n\n  var centralities = {};\n\n  graph.forEachNode(function (node) {\n    centralities[node] = getDegree(node) / ratio;\n  });\n\n  return centralities;\n}\n\n/**\n * Building various functions to export.\n */\nvar degreeCentrality = abstractDegreeCentrality.bind(null, false, 'degree');\nvar inDegreeCentrality = abstractDegreeCentrality.bind(null, false, 'inDegree');\nvar outDegreeCentrality = abstractDegreeCentrality.bind(\n  null,\n  false,\n  'outDegree'\n);\n\ndegreeCentrality.assign = abstractDegreeCentrality.bind(null, true, 'degree');\ninDegreeCentrality.assign = abstractDegreeCentrality.bind(\n  null,\n  true,\n  'inDegree'\n);\noutDegreeCentrality.assign = abstractDegreeCentrality.bind(\n  null,\n  true,\n  'outDegree'\n);\n\n/**\n * Exporting.\n */\nexports.degreeCentrality = degreeCentrality;\nexports.inDegreeCentrality = inDegreeCentrality;\nexports.outDegreeCentrality = outDegreeCentrality;\n", "exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';\nexports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';\n", "/**\n * Obliterator ForEach Function\n * =============================\n *\n * Helper function used to easily iterate over mixed values.\n */\nvar support = require('./support.js');\n\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n\n/**\n * Function able to iterate over almost any iterable JS value.\n *\n * @param  {any}      iterable - Iterable value.\n * @param  {function} callback - Callback function.\n */\nmodule.exports = function forEach(iterable, callback) {\n  var iterator, k, i, l, s;\n\n  if (!iterable) throw new Error('obliterator/forEach: invalid iterable.');\n\n  if (typeof callback !== 'function')\n    throw new Error('obliterator/forEach: expecting a callback.');\n\n  // The target is an array or a string or function arguments\n  if (\n    Array.isArray(iterable) ||\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable)) ||\n    typeof iterable === 'string' ||\n    iterable.toString() === '[object Arguments]'\n  ) {\n    for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);\n    return;\n  }\n\n  // The target has a #.forEach method\n  if (typeof iterable.forEach === 'function') {\n    iterable.forEach(callback);\n    return;\n  }\n\n  // The target is iterable\n  if (\n    SYMBOL_SUPPORT &&\n    Symbol.iterator in iterable &&\n    typeof iterable.next !== 'function'\n  ) {\n    iterable = iterable[Symbol.iterator]();\n  }\n\n  // The target is an iterator\n  if (typeof iterable.next === 'function') {\n    iterator = iterable;\n    i = 0;\n\n    while (((s = iterator.next()), s.done !== true)) {\n      callback(s.value, i);\n      i++;\n    }\n\n    return;\n  }\n\n  // The target is a plain object\n  for (k in iterable) {\n    if (iterable.hasOwnProperty(k)) {\n      callback(iterable[k], k);\n    }\n  }\n\n  return;\n};\n", "/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_8BIT_INTEGER)\n    return Uint8Array;\n\n  if (maxIndex <= MAX_16BIT_INTEGER)\n    return Uint16Array;\n\n  if (maxIndex <= MAX_32BIT_INTEGER)\n    return Uint32Array;\n\n  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');\n};\n\nexports.getSignedPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n    return Int8Array;\n\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n    return Int16Array;\n\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n    return Int32Array;\n\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function(value) {\n\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128)\n        return Int8Array;\n\n      if (value <= 32767 && value >= -32768)\n        return Int16Array;\n\n      return Int32Array;\n    }\n    else {\n\n      if (value <= 255)\n        return Uint8Array;\n\n      if (value <= 65535)\n        return Uint16Array;\n\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function(array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function(value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function() {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++)\n    length += arguments[i].length;\n\n  var array = new (arguments[0].constructor)(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function(length) {\n  var PointerArray = exports.getPointerArray(length);\n\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++)\n    array[i] = i;\n\n  return array;\n};\n", "/**\n * Mnemonist Iterable Function\n * ============================\n *\n * Harmonized iteration helpers over mixed iterable targets.\n */\nvar forEach = require('obliterator/foreach');\n\nvar typed = require('./typed-arrays.js');\n\n/**\n * Function used to determine whether the given object supports array-like\n * random access.\n *\n * @param  {any} target - Target object.\n * @return {boolean}\n */\nfunction isArrayLike(target) {\n  return Array.isArray(target) || typed.isTypedArray(target);\n}\n\n/**\n * Function used to guess the length of the structure over which we are going\n * to iterate.\n *\n * @param  {any} target - Target object.\n * @return {number|undefined}\n */\nfunction guessLength(target) {\n  if (typeof target.length === 'number')\n    return target.length;\n\n  if (typeof target.size === 'number')\n    return target.size;\n\n  return;\n}\n\n/**\n * Function used to convert an iterable to an array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArray(target) {\n  var l = guessLength(target);\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i++] = value;\n  });\n\n  return array;\n}\n\n/**\n * Same as above but returns a supplementary indices array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArrayWithIndices(target) {\n  var l = guessLength(target);\n\n  var IndexArray = typeof l === 'number' ?\n    typed.getPointerArray(l) :\n    Array;\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n  var indices = typeof l === 'number' ? new IndexArray(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i] = value;\n    indices[i] = i++;\n  });\n\n  return [array, indices];\n}\n\n/**\n * Exporting.\n */\nexports.isArrayLike = isArrayLike;\nexports.guessLength = guessLength;\nexports.toArray = toArray;\nexports.toArrayWithIndices = toArrayWithIndices;\n", "/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n  if (typeof next !== 'function')\n    throw new Error('obliterator/iterator: expecting a function!');\n\n  this.next = next;\n}\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function () {\n  var args = arguments,\n    l = args.length,\n    i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function () {\n  var iterator = new Iterator(function () {\n    return {done: true};\n  });\n\n  return iterator;\n};\n\n/**\n * Returning an iterator over the given indexed sequence.\n *\n * @param  {string|Array} sequence - Target sequence.\n * @return {Iterator}\n */\nIterator.fromSequence = function (sequence) {\n  var i = 0,\n    l = sequence.length;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: sequence[i++]};\n  });\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function (value) {\n  if (value instanceof Iterator) return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n", "/**\n * Mnemonist FixedDeque\n * =====================\n *\n * Fixed capacity double-ended queue implemented as ring deque.\n */\nvar iterables = require('./utils/iterables.js'),\n    Iterator = require('obliterator/iterator');\n\n/**\n * FixedDeque.\n *\n * @constructor\n */\nfunction FixedDeque(ArrayClass, capacity) {\n\n  if (arguments.length < 2)\n    throw new Error('mnemonist/fixed-deque: expecting an Array class and a capacity.');\n\n  if (typeof capacity !== 'number' || capacity <= 0)\n    throw new Error('mnemonist/fixed-deque: `capacity` should be a positive number.');\n\n  this.ArrayClass = ArrayClass;\n  this.capacity = capacity;\n  this.items = new ArrayClass(this.capacity);\n  this.clear();\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nFixedDeque.prototype.clear = function() {\n\n  // Properties\n  this.start = 0;\n  this.size = 0;\n};\n\n/**\n * Method used to append a value to the deque.\n *\n * @param  {any}    item - Item to append.\n * @return {number}      - Returns the new size of the deque.\n */\nFixedDeque.prototype.push = function(item) {\n  if (this.size === this.capacity)\n    throw new Error('mnemonist/fixed-deque.push: deque capacity (' + this.capacity + ') exceeded!');\n\n  var index = this.start + this.size;\n\n  if (index >= this.capacity)\n    index -= this.capacity;\n\n  this.items[index] = item;\n\n  return ++this.size;\n};\n\n/**\n * Method used to prepend a value to the deque.\n *\n * @param  {any}    item - Item to prepend.\n * @return {number}      - Returns the new size of the deque.\n */\nFixedDeque.prototype.unshift = function(item) {\n  if (this.size === this.capacity)\n    throw new Error('mnemonist/fixed-deque.unshift: deque capacity (' + this.capacity + ') exceeded!');\n\n  var index = this.start - 1;\n\n  if (this.start === 0)\n    index = this.capacity - 1;\n\n  this.items[index] = item;\n  this.start = index;\n\n  return ++this.size;\n};\n\n/**\n * Method used to pop the deque.\n *\n * @return {any} - Returns the popped item.\n */\nFixedDeque.prototype.pop = function() {\n  if (this.size === 0)\n    return;\n\n  this.size--;\n\n  var index = this.start + this.size;\n\n  if (index >= this.capacity)\n    index -= this.capacity;\n\n  return this.items[index];\n};\n\n/**\n * Method used to shift the deque.\n *\n * @return {any} - Returns the shifted item.\n */\nFixedDeque.prototype.shift = function() {\n  if (this.size === 0)\n    return;\n\n  var index = this.start;\n\n  this.size--;\n  this.start++;\n\n  if (this.start === this.capacity)\n    this.start = 0;\n\n  return this.items[index];\n};\n\n/**\n * Method used to peek the first value of the deque.\n *\n * @return {any}\n */\nFixedDeque.prototype.peekFirst = function() {\n  if (this.size === 0)\n    return;\n\n  return this.items[this.start];\n};\n\n/**\n * Method used to peek the last value of the deque.\n *\n * @return {any}\n */\nFixedDeque.prototype.peekLast = function() {\n  if (this.size === 0)\n    return;\n\n  var index = this.start + this.size - 1;\n\n  if (index >= this.capacity)\n    index -= this.capacity;\n\n  return this.items[index];\n};\n\n/**\n * Method used to get the desired value of the deque.\n *\n * @param  {number} index\n * @return {any}\n */\nFixedDeque.prototype.get = function(index) {\n  if (this.size === 0 || index >= this.capacity)\n    return;\n\n  index = this.start + index;\n\n  if (index >= this.capacity)\n    index -= this.capacity;\n\n  return this.items[index];\n};\n\n/**\n * Method used to iterate over the deque.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nFixedDeque.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    callback.call(scope, this.items[i], j, this);\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n  }\n};\n\n/**\n * Method used to convert the deque to a JavaScript array.\n *\n * @return {array}\n */\n// TODO: optional array class as argument?\nFixedDeque.prototype.toArray = function() {\n\n  // Optimization\n  var offset = this.start + this.size;\n\n  if (offset < this.capacity)\n    return this.items.slice(this.start, offset);\n\n  var array = new this.ArrayClass(this.size),\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  while (j < l) {\n    array[j] = this.items[i];\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n  }\n\n  return array;\n};\n\n/**\n * Method used to create an iterator over the deque's values.\n *\n * @return {Iterator}\n */\nFixedDeque.prototype.values = function() {\n  var items = this.items,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  return new Iterator(function() {\n    if (j >= l)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n\n    i++;\n    j++;\n\n    if (i === c)\n      i = 0;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over the deque's entries.\n *\n * @return {Iterator}\n */\nFixedDeque.prototype.entries = function() {\n  var items = this.items,\n      c = this.capacity,\n      l = this.size,\n      i = this.start,\n      j = 0;\n\n  return new Iterator(function() {\n    if (j >= l)\n      return {\n        done: true\n      };\n\n    var value = items[i];\n\n    i++;\n\n    if (i === c)\n      i = 0;\n\n    return {\n      value: [j++, value],\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  FixedDeque.prototype[Symbol.iterator] = FixedDeque.prototype.values;\n\n/**\n * Convenience known methods.\n */\nFixedDeque.prototype.inspect = function() {\n  var array = this.toArray();\n\n  array.type = this.ArrayClass.name;\n  array.capacity = this.capacity;\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: FixedDeque,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  FixedDeque.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedDeque.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a deque.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} ArrayClass - Array class to use.\n * @param  {number}   capacity   - Desired capacity.\n * @return {FiniteStack}\n */\nFixedDeque.from = function(iterable, ArrayClass, capacity) {\n  if (arguments.length < 3) {\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/fixed-deque.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n\n  var deque = new FixedDeque(ArrayClass, capacity);\n\n  if (iterables.isArrayLike(iterable)) {\n    var i, l;\n\n    for (i = 0, l = iterable.length; i < l; i++)\n      deque.items[i] = iterable[i];\n\n    deque.size = l;\n\n    return deque;\n  }\n\n  iterables.forEach(iterable, function(value) {\n    deque.push(value);\n  });\n\n  return deque;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = FixedDeque;\n", "/**\n * Mnemonist FixedStack\n * =====================\n *\n * The fixed stack is a stack whose capacity is defined beforehand and that\n * cannot be exceeded. This class is really useful when combined with\n * byte arrays to save up some memory and avoid memory re-allocation, hence\n * speeding up computations.\n *\n * This has however a downside: you need to know the maximum size you stack\n * can have during your iteration (which is not too difficult to compute when\n * performing, say, a DFS on a balanced binary tree).\n */\nvar Iterator = require('obliterator/iterator'),\n    iterables = require('./utils/iterables.js');\n\n/**\n * FixedStack\n *\n * @constructor\n * @param {function} ArrayClass - Array class to use.\n * @param {number}   capacity   - Desired capacity.\n */\nfunction FixedStack(ArrayClass, capacity) {\n\n  if (arguments.length < 2)\n    throw new Error('mnemonist/fixed-stack: expecting an Array class and a capacity.');\n\n  if (typeof capacity !== 'number' || capacity <= 0)\n    throw new Error('mnemonist/fixed-stack: `capacity` should be a positive number.');\n\n  this.capacity = capacity;\n  this.ArrayClass = ArrayClass;\n  this.items = new this.ArrayClass(this.capacity);\n  this.clear();\n}\n\n/**\n * Method used to clear the stack.\n *\n * @return {undefined}\n */\nFixedStack.prototype.clear = function() {\n\n  // Properties\n  this.size = 0;\n};\n\n/**\n * Method used to add an item to the stack.\n *\n * @param  {any}    item - Item to add.\n * @return {number}\n */\nFixedStack.prototype.push = function(item) {\n  if (this.size === this.capacity)\n    throw new Error('mnemonist/fixed-stack.push: stack capacity (' + this.capacity + ') exceeded!');\n\n  this.items[this.size++] = item;\n  return this.size;\n};\n\n/**\n * Method used to retrieve & remove the last item of the stack.\n *\n * @return {any}\n */\nFixedStack.prototype.pop = function() {\n  if (this.size === 0)\n    return;\n\n  return this.items[--this.size];\n};\n\n/**\n * Method used to get the last item of the stack.\n *\n * @return {any}\n */\nFixedStack.prototype.peek = function() {\n  return this.items[this.size - 1];\n};\n\n/**\n * Method used to iterate over the stack.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nFixedStack.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  for (var i = 0, l = this.items.length; i < l; i++)\n    callback.call(scope, this.items[l - i - 1], i, this);\n};\n\n/**\n * Method used to convert the stack to a JavaScript array.\n *\n * @return {array}\n */\nFixedStack.prototype.toArray = function() {\n  var array = new this.ArrayClass(this.size),\n      l = this.size - 1,\n      i = this.size;\n\n  while (i--)\n    array[i] = this.items[l - i];\n\n  return array;\n};\n\n/**\n * Method used to create an iterator over a stack's values.\n *\n * @return {Iterator}\n */\nFixedStack.prototype.values = function() {\n  var items = this.items,\n      l = this.size,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {\n        done: true\n      };\n\n    var value = items[l - i - 1];\n    i++;\n\n    return {\n      value: value,\n      done: false\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over a stack's entries.\n *\n * @return {Iterator}\n */\nFixedStack.prototype.entries = function() {\n  var items = this.items,\n      l = this.size,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {\n        done: true\n      };\n\n    var value = items[l - i - 1];\n\n    return {\n      value: [i++, value],\n      done: false\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  FixedStack.prototype[Symbol.iterator] = FixedStack.prototype.values;\n\n\n/**\n * Convenience known methods.\n */\nFixedStack.prototype.toString = function() {\n  return this.toArray().join(',');\n};\n\nFixedStack.prototype.toJSON = function() {\n  return this.toArray();\n};\n\nFixedStack.prototype.inspect = function() {\n  var array = this.toArray();\n\n  array.type = this.ArrayClass.name;\n  array.capacity = this.capacity;\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(array, 'constructor', {\n    value: FixedStack,\n    enumerable: false\n  });\n\n  return array;\n};\n\nif (typeof Symbol !== 'undefined')\n  FixedStack.prototype[Symbol.for('nodejs.util.inspect.custom')] = FixedStack.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a stack.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} ArrayClass - Array class to use.\n * @param  {number}   capacity   - Desired capacity.\n * @return {FixedStack}\n */\nFixedStack.from = function(iterable, ArrayClass, capacity) {\n\n  if (arguments.length < 3) {\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/fixed-stack.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n\n  var stack = new FixedStack(ArrayClass, capacity);\n\n  if (iterables.isArrayLike(iterable)) {\n    var i, l;\n\n    for (i = 0, l = iterable.length; i < l; i++)\n      stack.items[i] = iterable[i];\n\n    stack.size = l;\n\n    return stack;\n  }\n\n  iterables.forEach(iterable, function(value) {\n    stack.push(value);\n  });\n\n  return stack;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = FixedStack;\n", "/**\n * Mnemonist Heap Comparators\n * ===========================\n *\n * Default comparators & functions dealing with comparators reversing etc.\n */\nvar DEFAULT_COMPARATOR = function(a, b) {\n  if (a < b)\n    return -1;\n  if (a > b)\n    return 1;\n\n  return 0;\n};\n\nvar DEFAULT_REVERSE_COMPARATOR = function(a, b) {\n  if (a < b)\n    return 1;\n  if (a > b)\n    return -1;\n\n  return 0;\n};\n\n/**\n * Function used to reverse a comparator.\n */\nfunction reverseComparator(comparator) {\n  return function(a, b) {\n    return comparator(b, a);\n  };\n}\n\n/**\n * Function returning a tuple comparator.\n */\nfunction createTupleComparator(size) {\n  if (size === 2) {\n    return function(a, b) {\n      if (a[0] < b[0])\n        return -1;\n\n      if (a[0] > b[0])\n        return 1;\n\n      if (a[1] < b[1])\n        return -1;\n\n      if (a[1] > b[1])\n        return 1;\n\n      return 0;\n    };\n  }\n\n  return function(a, b) {\n    var i = 0;\n\n    while (i < size) {\n      if (a[i] < b[i])\n        return -1;\n\n      if (a[i] > b[i])\n        return 1;\n\n      i++;\n    }\n\n    return 0;\n  };\n}\n\n/**\n * Exporting.\n */\nexports.DEFAULT_COMPARATOR = DEFAULT_COMPARATOR;\nexports.DEFAULT_REVERSE_COMPARATOR = DEFAULT_REVERSE_COMPARATOR;\nexports.reverseComparator = reverseComparator;\nexports.createTupleComparator = createTupleComparator;\n", "/**\n * Mnemonist Binary Heap\n * ======================\n *\n * Binary heap implementation.\n */\nvar forEach = require('obliterator/foreach'),\n    comparators = require('./utils/comparators.js'),\n    iterables = require('./utils/iterables.js');\n\nvar DEFAULT_COMPARATOR = comparators.DEFAULT_COMPARATOR,\n    reverseComparator = comparators.reverseComparator;\n\n/**\n * Heap helper functions.\n */\n\n/**\n * Function used to sift down.\n *\n * @param {function} compare    - Comparison function.\n * @param {array}    heap       - Array storing the heap's data.\n * @param {number}   startIndex - Starting index.\n * @param {number}   i          - Index.\n */\nfunction siftDown(compare, heap, startIndex, i) {\n  var item = heap[i],\n      parentIndex,\n      parent;\n\n  while (i > startIndex) {\n    parentIndex = (i - 1) >> 1;\n    parent = heap[parentIndex];\n\n    if (compare(item, parent) < 0) {\n      heap[i] = parent;\n      i = parentIndex;\n      continue;\n    }\n\n    break;\n  }\n\n  heap[i] = item;\n}\n\n/**\n * Function used to sift up.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {number}   i       - Index.\n */\nfunction siftUp(compare, heap, i) {\n  var endIndex = heap.length,\n      startIndex = i,\n      item = heap[i],\n      childIndex = 2 * i + 1,\n      rightIndex;\n\n  while (childIndex < endIndex) {\n    rightIndex = childIndex + 1;\n\n    if (\n      rightIndex < endIndex &&\n      compare(heap[childIndex], heap[rightIndex]) >= 0\n    ) {\n      childIndex = rightIndex;\n    }\n\n    heap[i] = heap[childIndex];\n    i = childIndex;\n    childIndex = 2 * i + 1;\n  }\n\n  heap[i] = item;\n  siftDown(compare, heap, startIndex, i);\n}\n\n/**\n * Function used to push an item into a heap represented by a raw array.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    heap    - Array storing the heap's data.\n * @param {any}      item    - Item to push.\n */\nfunction push(compare, heap, item) {\n  heap.push(item);\n  siftDown(compare, heap, 0, heap.length - 1);\n}\n\n/**\n * Function used to pop an item from a heap represented by a raw array.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {any}\n */\nfunction pop(compare, heap) {\n  var lastItem = heap.pop();\n\n  if (heap.length !== 0) {\n    var item = heap[0];\n    heap[0] = lastItem;\n    siftUp(compare, heap, 0);\n\n    return item;\n  }\n\n  return lastItem;\n}\n\n/**\n * Function used to pop the heap then push a new value into it, thus \"replacing\"\n * it.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction replace(compare, heap, item) {\n  if (heap.length === 0)\n    throw new Error('mnemonist/heap.replace: cannot pop an empty heap.');\n\n  var popped = heap[0];\n  heap[0] = item;\n  siftUp(compare, heap, 0);\n\n  return popped;\n}\n\n/**\n * Function used to push an item in the heap then pop the heap and return the\n * popped value.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @param  {any}      item    - The item to push.\n * @return {any}\n */\nfunction pushpop(compare, heap, item) {\n  var tmp;\n\n  if (heap.length !== 0 && compare(heap[0], item) < 0) {\n    tmp = heap[0];\n    heap[0] = item;\n    item = tmp;\n    siftUp(compare, heap, 0);\n  }\n\n  return item;\n}\n\n/**\n * Converts and array into an abstract heap in linear time.\n *\n * @param {function} compare - Comparison function.\n * @param {array}    array   - Target array.\n */\nfunction heapify(compare, array) {\n  var n = array.length,\n      l = n >> 1,\n      i = l;\n\n  while (--i >= 0)\n    siftUp(compare, array, i);\n}\n\n/**\n * Fully consumes the given heap.\n *\n * @param  {function} compare - Comparison function.\n * @param  {array}    heap    - Array storing the heap's data.\n * @return {array}\n */\nfunction consume(compare, heap) {\n  var l = heap.length,\n      i = 0;\n\n  var array = new Array(l);\n\n  while (i < l)\n    array[i++] = pop(compare, heap);\n\n  return array;\n}\n\n/**\n * Function used to retrieve the n smallest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nsmallest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var min = Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the minimum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (min === Infinity || compare(v, min) < 0)\n          min = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = min;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (min === Infinity || compare(value, min) < 0)\n        min = value;\n    });\n\n    return [min];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(compare);\n\n    result = iterable.slice(0, n);\n    heapify(reverseCompare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (reverseCompare(iterable[i], result[0]) > 0)\n        replace(reverseCompare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(compare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(reverseCompare, result);\n\n      if (reverseCompare(value, result[0]) > 0)\n        replace(reverseCompare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(compare);\n}\n\n/**\n * Function used to retrieve the n largest items from the given iterable.\n *\n * @param {function} compare  - Comparison function.\n * @param {number}   n        - Number of top items to retrieve.\n * @param {any}      iterable - Arbitrary iterable.\n * @param {array}\n */\nfunction nlargest(compare, n, iterable) {\n  if (arguments.length === 2) {\n    iterable = n;\n    n = compare;\n    compare = DEFAULT_COMPARATOR;\n  }\n\n  var reverseCompare = reverseComparator(compare);\n\n  var i, l, v;\n\n  var max = -Infinity;\n\n  var result;\n\n  // If n is equal to 1, it's just a matter of finding the maximum\n  if (n === 1) {\n    if (iterables.isArrayLike(iterable)) {\n      for (i = 0, l = iterable.length; i < l; i++) {\n        v = iterable[i];\n\n        if (max === -Infinity || compare(v, max) > 0)\n          max = v;\n      }\n\n      result = new iterable.constructor(1);\n      result[0] = max;\n\n      return result;\n    }\n\n    forEach(iterable, function(value) {\n      if (max === -Infinity || compare(value, max) > 0)\n        max = value;\n    });\n\n    return [max];\n  }\n\n  if (iterables.isArrayLike(iterable)) {\n\n    // If n > iterable length, we just clone and sort\n    if (n >= iterable.length)\n      return iterable.slice().sort(reverseCompare);\n\n    result = iterable.slice(0, n);\n    heapify(compare, result);\n\n    for (i = n, l = iterable.length; i < l; i++)\n      if (compare(iterable[i], result[0]) > 0)\n        replace(compare, result, iterable[i]);\n\n    // NOTE: if n is over some number, it becomes faster to consume the heap\n    return result.sort(reverseCompare);\n  }\n\n  // Correct for size\n  var size = iterables.guessLength(iterable);\n\n  if (size !== null && size < n)\n    n = size;\n\n  result = new Array(n);\n  i = 0;\n\n  forEach(iterable, function(value) {\n    if (i < n) {\n      result[i] = value;\n    }\n    else {\n      if (i === n)\n        heapify(compare, result);\n\n      if (compare(value, result[0]) > 0)\n        replace(compare, result, value);\n    }\n\n    i++;\n  });\n\n  if (result.length > i)\n    result.length = i;\n\n  // NOTE: if n is over some number, it becomes faster to consume the heap\n  return result.sort(reverseCompare);\n}\n\n/**\n * Binary Minimum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction Heap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/Heap.constructor: given comparator should be a function.');\n}\n\n/**\n * Method used to clear the heap.\n *\n * @return {undefined}\n */\nHeap.prototype.clear = function() {\n\n  // Properties\n  this.items = [];\n  this.size = 0;\n};\n\n/**\n * Method used to push an item into the heap.\n *\n * @param  {any}    item - Item to push.\n * @return {number}\n */\nHeap.prototype.push = function(item) {\n  push(this.comparator, this.items, item);\n  return ++this.size;\n};\n\n/**\n * Method used to retrieve the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.peek = function() {\n  return this.items[0];\n};\n\n/**\n * Method used to retrieve & remove the \"first\" item of the heap.\n *\n * @return {any}\n */\nHeap.prototype.pop = function() {\n  if (this.size !== 0)\n    this.size--;\n\n  return pop(this.comparator, this.items);\n};\n\n/**\n * Method used to pop the heap, then push an item and return the popped\n * item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.replace = function(item) {\n  return replace(this.comparator, this.items, item);\n};\n\n/**\n * Method used to push the heap, the pop it and return the pooped item.\n *\n * @param  {any} item - Item to push into the heap.\n * @return {any}\n */\nHeap.prototype.pushpop = function(item) {\n  return pushpop(this.comparator, this.items, item);\n};\n\n/**\n * Method used to consume the heap fully and return its items as a sorted array.\n *\n * @return {array}\n */\nHeap.prototype.consume = function() {\n  this.size = 0;\n  return consume(this.comparator, this.items);\n};\n\n/**\n * Method used to convert the heap to an array. Note that it basically clone\n * the heap and consumes it completely. This is hardly performant.\n *\n * @return {array}\n */\nHeap.prototype.toArray = function() {\n  return consume(this.comparator, this.items.slice());\n};\n\n/**\n * Convenience known methods.\n */\nHeap.prototype.inspect = function() {\n  var proxy = this.toArray();\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: Heap,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  Heap.prototype[Symbol.for('nodejs.util.inspect.custom')] = Heap.prototype.inspect;\n\n/**\n * Binary Maximum Heap.\n *\n * @constructor\n * @param {function} comparator - Comparator function to use.\n */\nfunction MaxHeap(comparator) {\n  this.clear();\n  this.comparator = comparator || DEFAULT_COMPARATOR;\n\n  if (typeof this.comparator !== 'function')\n    throw new Error('mnemonist/MaxHeap.constructor: given comparator should be a function.');\n\n  this.comparator = reverseComparator(this.comparator);\n}\n\nMaxHeap.prototype = Heap.prototype;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a heap.\n *\n * @param  {Iterable} iterable   - Target iterable.\n * @param  {function} comparator - Custom comparator function.\n * @return {Heap}\n */\nHeap.from = function(iterable, comparator) {\n  var heap = new Heap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\nMaxHeap.from = function(iterable, comparator) {\n  var heap = new MaxHeap(comparator);\n\n  var items;\n\n  // If iterable is an array, we can be clever about it\n  if (iterables.isArrayLike(iterable))\n    items = iterable.slice();\n  else\n    items = iterables.toArray(iterable);\n\n  heapify(heap.comparator, items);\n  heap.items = items;\n  heap.size = items.length;\n\n  return heap;\n};\n\n/**\n * Exporting.\n */\nHeap.siftUp = siftUp;\nHeap.siftDown = siftDown;\nHeap.push = push;\nHeap.pop = pop;\nHeap.replace = replace;\nHeap.pushpop = pushpop;\nHeap.heapify = heapify;\nHeap.consume = consume;\n\nHeap.nsmallest = nsmallest;\nHeap.nlargest = nlargest;\n\nHeap.MinHeap = Heap;\nHeap.MaxHeap = MaxHeap;\n\nmodule.exports = Heap;\n", "/**\n * Graphology Weight Getter\n * =========================\n *\n * Function creating weight getters.\n */\nfunction coerceWeight(value) {\n  // Ensuring target value is a correct number\n  if (typeof value !== 'number' || isNaN(value)) return 1;\n\n  return value;\n}\n\nfunction createNodeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, node) {\n      return get(graph.getNodeAttributes(node));\n    };\n    getter.fromEntry = function (node, attributes) {\n      return get(attributes);\n    };\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createNodeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, node) {\n      return coerceToDefault(\n        nameOrFunction(node, graph.getNodeAttributes(node))\n      );\n    };\n    getter.fromEntry = function (node, attributes) {\n      return coerceToDefault(nameOrFunction(node, attributes));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nfunction createEdgeValueGetter(nameOrFunction, defaultValue) {\n  var getter = {};\n\n  var coerceToDefault = function (v) {\n    if (typeof v === 'undefined') return defaultValue;\n\n    return v;\n  };\n\n  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;\n\n  var get = function (attributes) {\n    return coerceToDefault(attributes[nameOrFunction]);\n  };\n\n  var returnDefault = function () {\n    return coerceToDefault(undefined);\n  };\n\n  if (typeof nameOrFunction === 'string') {\n    getter.fromAttributes = get;\n    getter.fromGraph = function (graph, edge) {\n      return get(graph.getEdgeAttributes(edge));\n    };\n    getter.fromEntry = function (edge, attributes) {\n      return get(attributes);\n    };\n    getter.fromPartialEntry = getter.fromEntry;\n    getter.fromMinimalEntry = getter.fromEntry;\n  } else if (typeof nameOrFunction === 'function') {\n    getter.fromAttributes = function () {\n      throw new Error(\n        'graphology-utils/getters/createEdgeValueGetter: irrelevant usage.'\n      );\n    };\n    getter.fromGraph = function (graph, edge) {\n      // TODO: we can do better, check #310\n      var extremities = graph.extremities(edge);\n      return coerceToDefault(\n        nameOrFunction(\n          edge,\n          graph.getEdgeAttributes(edge),\n          extremities[0],\n          extremities[1],\n          graph.getNodeAttributes(extremities[0]),\n          graph.getNodeAttributes(extremities[1]),\n          graph.isUndirected(edge)\n        )\n      );\n    };\n    getter.fromEntry = function (e, a, s, t, sa, ta, u) {\n      return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));\n    };\n    getter.fromPartialEntry = function (e, a, s, t) {\n      return coerceToDefault(nameOrFunction(e, a, s, t));\n    };\n    getter.fromMinimalEntry = function (e, a) {\n      return coerceToDefault(nameOrFunction(e, a));\n    };\n  } else {\n    getter.fromAttributes = returnDefault;\n    getter.fromGraph = returnDefault;\n    getter.fromEntry = returnDefault;\n    getter.fromMinimalEntry = returnDefault;\n  }\n\n  return getter;\n}\n\nexports.createNodeValueGetter = createNodeValueGetter;\nexports.createEdgeValueGetter = createEdgeValueGetter;\nexports.createEdgeWeightGetter = function (name) {\n  return createEdgeValueGetter(name, coerceWeight);\n};\n", "/**\n * Graphology Neighborhood Indices\n * ================================\n */\nvar typed = require('mnemonist/utils/typed-arrays');\nvar createEdgeWeightGetter =\n  require('graphology-utils/getters').createEdgeWeightGetter;\n\nfunction upperBoundPerMethod(method, graph) {\n  if (method === 'outbound' || method === 'inbound')\n    return graph.directedSize + graph.undirectedSize * 2;\n\n  if (method === 'in' || method === 'out' || method === 'directed')\n    return graph.directedSize;\n\n  return graph.undirectedSize * 2;\n}\n\nfunction NeighborhoodIndex(graph, method) {\n  method = method || 'outbound';\n  var getNeighbors = graph[method + 'Neighbors'].bind(graph);\n\n  var upperBound = upperBoundPerMethod(method, graph);\n\n  var NeighborhoodPointerArray = typed.getPointerArray(upperBound);\n  var NodesPointerArray = typed.getPointerArray(graph.order);\n\n  // NOTE: directedSize + undirectedSize * 2 is an upper bound for\n  // neighborhood size\n  this.graph = graph;\n  this.neighborhood = new NodesPointerArray(upperBound);\n\n  this.starts = new NeighborhoodPointerArray(graph.order + 1);\n\n  this.nodes = graph.nodes();\n\n  var ids = {};\n\n  var i, l, j, m, node, neighbors;\n\n  var n = 0;\n\n  for (i = 0, l = graph.order; i < l; i++) ids[this.nodes[i]] = i;\n\n  for (i = 0, l = graph.order; i < l; i++) {\n    node = this.nodes[i];\n    neighbors = getNeighbors(node);\n\n    this.starts[i] = n;\n\n    for (j = 0, m = neighbors.length; j < m; j++)\n      this.neighborhood[n++] = ids[neighbors[j]];\n  }\n\n  // NOTE: we keep one more index as upper bound to simplify iteration\n  this.starts[i] = upperBound;\n}\n\nNeighborhoodIndex.prototype.bounds = function (i) {\n  return [this.starts[i], this.starts[i + 1]];\n};\n\nNeighborhoodIndex.prototype.project = function () {\n  var self = this;\n\n  var projection = {};\n\n  self.nodes.forEach(function (node, i) {\n    projection[node] = Array.from(\n      self.neighborhood.slice(self.starts[i], self.starts[i + 1])\n    ).map(function (j) {\n      return self.nodes[j];\n    });\n  });\n\n  return projection;\n};\n\nNeighborhoodIndex.prototype.collect = function (results) {\n  var i, l;\n\n  var o = {};\n\n  for (i = 0, l = results.length; i < l; i++) o[this.nodes[i]] = results[i];\n\n  return o;\n};\n\nNeighborhoodIndex.prototype.assign = function (prop, results) {\n  var i = 0;\n\n  this.graph.updateEachNodeAttributes(\n    function (_, attr) {\n      attr[prop] = results[i++];\n\n      return attr;\n    },\n    {attributes: [prop]}\n  );\n};\n\nexports.NeighborhoodIndex = NeighborhoodIndex;\n\nfunction WeightedNeighborhoodIndex(graph, getEdgeWeight, method) {\n  method = method || 'outbound';\n  var getEdges = graph[method + 'Edges'].bind(graph);\n\n  var upperBound = upperBoundPerMethod(method, graph);\n\n  var NeighborhoodPointerArray = typed.getPointerArray(upperBound);\n  var NodesPointerArray = typed.getPointerArray(graph.order);\n\n  var weightGetter = createEdgeWeightGetter(getEdgeWeight).fromMinimalEntry;\n\n  // NOTE: directedSize + undirectedSize * 2 is an upper bound for\n  // neighborhood size\n  this.graph = graph;\n  this.neighborhood = new NodesPointerArray(upperBound);\n  this.weights = new Float64Array(upperBound);\n  this.outDegrees = new Float64Array(graph.order);\n\n  this.starts = new NeighborhoodPointerArray(graph.order + 1);\n\n  this.nodes = graph.nodes();\n\n  var ids = {};\n\n  var i, l, j, m, node, neighbor, edges, edge, weight;\n\n  var n = 0;\n\n  for (i = 0, l = graph.order; i < l; i++) ids[this.nodes[i]] = i;\n\n  for (i = 0, l = graph.order; i < l; i++) {\n    node = this.nodes[i];\n    edges = getEdges(node);\n\n    this.starts[i] = n;\n\n    for (j = 0, m = edges.length; j < m; j++) {\n      edge = edges[j];\n      neighbor = graph.opposite(node, edge);\n      weight = weightGetter(edge, graph.getEdgeAttributes(edge));\n\n      // NOTE: for weighted mixed beware of merging weights if twice the same neighbor\n      this.neighborhood[n] = ids[neighbor];\n      this.weights[n++] = weight;\n      this.outDegrees[i] += weight;\n    }\n  }\n\n  // NOTE: we keep one more index as upper bound to simplify iteration\n  this.starts[i] = upperBound;\n}\n\nWeightedNeighborhoodIndex.prototype.bounds = NeighborhoodIndex.prototype.bounds;\nWeightedNeighborhoodIndex.prototype.project =\n  NeighborhoodIndex.prototype.project;\nWeightedNeighborhoodIndex.prototype.collect =\n  NeighborhoodIndex.prototype.collect;\nWeightedNeighborhoodIndex.prototype.assign = NeighborhoodIndex.prototype.assign;\n\nexports.WeightedNeighborhoodIndex = WeightedNeighborhoodIndex;\n", "/**\n * Graphology Indexed Brandes Routine\n * ===================================\n *\n * Indexed version of the famous Brandes routine aiming at computing\n * betweenness centrality efficiently.\n */\nvar FixedDeque = require('mnemonist/fixed-deque');\nvar FixedStack = require('mnemonist/fixed-stack');\nvar Heap = require('mnemonist/heap');\nvar typed = require('mnemonist/utils/typed-arrays');\nvar neighborhoodIndices = require('graphology-indices/neighborhood');\n\nvar NeighborhoodIndex = neighborhoodIndices.NeighborhoodIndex;\nvar WeightedNeighborhoodIndex = neighborhoodIndices.WeightedNeighborhoodIndex;\n\n/**\n * Indexed unweighted Brandes routine.\n *\n * [Reference]:\n * Ulrik Brandes: A Faster Algorithm for Betweenness Centrality.\n * Journal of Mathematical Sociology 25(2):163-177, 2001.\n *\n * @param  {Graph}    graph - The graphology instance.\n * @return {function}\n */\nexports.createUnweightedIndexedBrandes =\n  function createUnweightedIndexedBrandes(graph) {\n    var neighborhoodIndex = new NeighborhoodIndex(graph);\n\n    var neighborhood = neighborhoodIndex.neighborhood,\n      starts = neighborhoodIndex.starts;\n\n    var order = graph.order;\n\n    var S = new FixedStack(typed.getPointerArray(order), order),\n      sigma = new Uint32Array(order),\n      P = new Array(order),\n      D = new Int32Array(order);\n\n    var Q = new FixedDeque(Uint32Array, order);\n\n    var brandes = function (sourceIndex) {\n      var Dv, sigmav, start, stop, j, v, w;\n\n      for (v = 0; v < order; v++) {\n        P[v] = [];\n        sigma[v] = 0;\n        D[v] = -1;\n      }\n\n      sigma[sourceIndex] = 1;\n      D[sourceIndex] = 0;\n\n      Q.push(sourceIndex);\n\n      while (Q.size !== 0) {\n        v = Q.shift();\n        S.push(v);\n\n        Dv = D[v];\n        sigmav = sigma[v];\n\n        start = starts[v];\n        stop = starts[v + 1];\n\n        for (j = start; j < stop; j++) {\n          w = neighborhood[j];\n\n          if (D[w] === -1) {\n            Q.push(w);\n            D[w] = Dv + 1;\n          }\n\n          if (D[w] === Dv + 1) {\n            sigma[w] += sigmav;\n            P[w].push(v);\n          }\n        }\n      }\n\n      return [S, P, sigma];\n    };\n\n    brandes.index = neighborhoodIndex;\n\n    return brandes;\n  };\n\nfunction BRANDES_DIJKSTRA_HEAP_COMPARATOR(a, b) {\n  if (a[0] > b[0]) return 1;\n  if (a[0] < b[0]) return -1;\n\n  if (a[1] > b[1]) return 1;\n  if (a[1] < b[1]) return -1;\n\n  if (a[2] > b[2]) return 1;\n  if (a[2] < b[2]) return -1;\n\n  if (a[3] > b[3]) return 1;\n  if (a[3] < b[3]) return -1;\n\n  return 0;\n}\n\n/**\n * Indexed Dijkstra Brandes routine.\n *\n * [Reference]:\n * Ulrik Brandes: A Faster Algorithm for Betweenness Centrality.\n * Journal of Mathematical Sociology 25(2):163-177, 2001.\n *\n * @param  {Graph}    graph         - The graphology instance.\n * @param  {string}   getEdgeWeight - Name of the weight attribute or getter function.\n * @return {function}\n */\nexports.createDijkstraIndexedBrandes = function createDijkstraIndexedBrandes(\n  graph,\n  getEdgeWeight\n) {\n  var neighborhoodIndex = new WeightedNeighborhoodIndex(\n    graph,\n    getEdgeWeight || 'weight'\n  );\n\n  var neighborhood = neighborhoodIndex.neighborhood,\n    weights = neighborhoodIndex.weights,\n    starts = neighborhoodIndex.starts;\n\n  var order = graph.order;\n\n  var S = new FixedStack(typed.getPointerArray(order), order),\n    sigma = new Uint32Array(order),\n    P = new Array(order),\n    D = new Float64Array(order),\n    seen = new Float64Array(order);\n\n  // TODO: use fixed-size heap\n  var Q = new Heap(BRANDES_DIJKSTRA_HEAP_COMPARATOR);\n\n  var brandes = function (sourceIndex) {\n    var start, stop, item, dist, pred, cost, j, v, w;\n\n    var count = 0;\n\n    for (v = 0; v < order; v++) {\n      P[v] = [];\n      sigma[v] = 0;\n      D[v] = -1;\n      seen[v] = -1;\n    }\n\n    sigma[sourceIndex] = 1;\n    seen[sourceIndex] = 0;\n\n    Q.push([0, count++, sourceIndex, sourceIndex]);\n\n    while (Q.size !== 0) {\n      item = Q.pop();\n      dist = item[0];\n      pred = item[2];\n      v = item[3];\n\n      if (D[v] !== -1) continue;\n\n      S.push(v);\n      D[v] = dist;\n      sigma[v] += sigma[pred];\n\n      start = starts[v];\n      stop = starts[v + 1];\n\n      for (j = start; j < stop; j++) {\n        w = neighborhood[j];\n        cost = dist + weights[j];\n\n        if (D[w] === -1 && (seen[w] === -1 || cost < seen[w])) {\n          seen[w] = cost;\n          Q.push([cost, count++, v, w]);\n          sigma[w] = 0;\n          P[w] = [v];\n        } else if (cost === seen[w]) {\n          sigma[w] += sigma[v];\n          P[w].push(v);\n        }\n      }\n    }\n\n    return [S, P, sigma];\n  };\n\n  brandes.index = neighborhoodIndex;\n\n  return brandes;\n};\n", "/**\n * Graphology Defaults\n * ====================\n *\n * Helper function used throughout the standard lib to resolve defaults.\n */\nfunction isLeaf(o) {\n  return (\n    !o ||\n    typeof o !== 'object' ||\n    typeof o === 'function' ||\n    Array.isArray(o) ||\n    o instanceof Set ||\n    o instanceof Map ||\n    o instanceof RegExp ||\n    o instanceof Date\n  );\n}\n\nfunction resolveDefaults(target, defaults) {\n  target = target || {};\n\n  var output = {};\n\n  for (var k in defaults) {\n    var existing = target[k];\n    var def = defaults[k];\n\n    // Recursion\n    if (!isLeaf(def)) {\n      output[k] = resolveDefaults(existing, def);\n\n      continue;\n    }\n\n    // Leaf\n    if (existing === undefined) {\n      output[k] = def;\n    } else {\n      output[k] = existing;\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = resolveDefaults;\n", "/**\n * Graphology Betweenness Centrality\n * ==================================\n *\n * Function computing betweenness centrality.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar lib = require('graphology-shortest-path/indexed-brandes');\nvar resolveDefaults = require('graphology-utils/defaults');\n\nvar createUnweightedIndexedBrandes = lib.createUnweightedIndexedBrandes;\nvar createDijkstraIndexedBrandes = lib.createDijkstraIndexedBrandes;\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  nodeCentralityAttribute: 'betweennessCentrality',\n  getEdgeWeight: 'weight',\n  normalized: true\n};\n\n/**\n * Abstract function computing beetweenness centrality for the given graph.\n *\n * @param  {boolean} assign                      - Assign the results to node attributes?\n * @param  {Graph}   graph                       - Target graph.\n * @param  {object}  [options]                   - Options:\n * @param  {object}    [nodeCentralityAttribute] - Name of the attribute to assign.\n * @param  {string}    [getEdgeWeight]           - Name of the weight attribute or getter function.\n * @param  {boolean}   [normalized]              - Should the centrality be normalized?\n * @param  {object}\n */\nfunction abstractBetweennessCentrality(assign, graph, options) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-centrality/beetweenness-centrality: the given graph is not a valid graphology instance.'\n    );\n\n  // Solving options\n  options = resolveDefaults(options, DEFAULTS);\n\n  var outputName = options.nodeCentralityAttribute;\n  var normalized = options.normalized;\n\n  var brandes = options.getEdgeWeight\n    ? createDijkstraIndexedBrandes(graph, options.getEdgeWeight)\n    : createUnweightedIndexedBrandes(graph);\n\n  var N = graph.order;\n\n  var result, S, P, sigma, coefficient, i, j, m, v, w;\n\n  var delta = new Float64Array(N);\n  var centralities = new Float64Array(N);\n\n  // Iterating over each node\n  for (i = 0; i < N; i++) {\n    result = brandes(i);\n\n    S = result[0];\n    P = result[1];\n    sigma = result[2];\n\n    // Accumulating\n    j = S.size;\n\n    while (j--) delta[S.items[S.size - j]] = 0;\n\n    while (S.size !== 0) {\n      w = S.pop();\n      coefficient = (1 + delta[w]) / sigma[w];\n\n      for (j = 0, m = P[w].length; j < m; j++) {\n        v = P[w][j];\n        delta[v] += sigma[v] * coefficient;\n      }\n\n      if (w !== i) centralities[w] += delta[w];\n    }\n  }\n\n  // Rescaling\n  var scale = null;\n\n  if (normalized) scale = N <= 2 ? null : 1 / ((N - 1) * (N - 2));\n  else scale = graph.type === 'undirected' ? 0.5 : null;\n\n  if (scale !== null) {\n    for (i = 0; i < N; i++) centralities[i] *= scale;\n  }\n\n  if (assign) return brandes.index.assign(outputName, centralities);\n\n  return brandes.index.collect(centralities);\n}\n\n/**\n * Exporting.\n */\nvar betweennessCentrality = abstractBetweennessCentrality.bind(null, false);\nbetweennessCentrality.assign = abstractBetweennessCentrality.bind(null, true);\n\nmodule.exports = betweennessCentrality;\n", "/**\n * Graphology Betweenness Centrality\n * ==================================\n *\n * Function computing betweenness centrality.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar lib = require('graphology-shortest-path/indexed-brandes');\nvar resolveDefaults = require('graphology-utils/defaults');\n\nvar createUnweightedIndexedBrandes = lib.createUnweightedIndexedBrandes;\nvar createDijkstraIndexedBrandes = lib.createDijkstraIndexedBrandes;\n\n/**\n * Defaults.\n */\n\nvar DEFAULTS = {\n  edgeCentralityAttribute: 'betweennessCentrality',\n  getEdgeWeight: 'weight',\n  normalized: true\n};\n\n/**\n * Abstract function computing edge beetweenness centrality for the given graph.\n *\n * @param  {boolean}   assign                      - Assign the results to node attributes?\n * @param  {Graph}     graph                       - Target graph.\n * @param  {object}    [options]                   - Options:\n * @param  {object}    [edgeCentralityAttribute] - Name of the attribute to assign.\n * @param  {string}    [getEdgeWeight]           - Name of the weight attribute or getter function.\n * @param  {boolean}   [normalized]              - Should the centrality be normalized?\n * @param  {object}\n */\nfunction abstractEdgeBetweennessCentrality(assign, graph, options) {\n  if (!isGraph(graph)) {\n    throw new Error(\n      'graphology-centrality/edge-beetweenness-centrality: the given graph is not a valid graphology instance.'\n    );\n  }\n\n  // Solving options\n  options = resolveDefaults(options, DEFAULTS);\n\n  var outputName = options.edgeCentralityAttribute;\n  var normalized = options.normalized;\n\n  var brandes = options.getEdgeWeight\n    ? createDijkstraIndexedBrandes(graph, options.getEdgeWeight)\n    : createUnweightedIndexedBrandes(graph);\n\n  var order = graph.order;\n  var result, S, P, sigma, coefficient, i, j, m, v, c, w, wn;\n\n  var delta = new Float64Array(order);\n  var edgeCentralities = {};\n\n  graph.forEachEdge(function (edge) {\n    edgeCentralities[edge] = 0.0;\n  });\n\n  var nodes = brandes.index.nodes;\n\n  // Iterating over each node\n  for (i = 0; i < order; i++) {\n    result = brandes(i);\n\n    S = result[0];\n    P = result[1];\n    sigma = result[2];\n\n    // Accumulating\n    j = S.size;\n\n    while (j--) delta[S.items[S.size - j]] = 0;\n\n    // accumulate edges\n    while (S.size !== 0) {\n      w = S.pop();\n      coefficient = (1 + delta[w]) / sigma[w];\n      wn = nodes[w];\n      for (j = 0, m = P[w].length; j < m; j++) {\n        v = P[w][j];\n        c = sigma[v] * coefficient;\n\n        // TODO: this is hardly optimal, but the good\n        // solution implies to add some variant of the\n        // neighboorhood index and brandes routine which\n        // will be quite time-consuming.\n        var vw = graph.edge(nodes[v], wn);\n        edgeCentralities[vw] += c;\n\n        delta[v] += c;\n      }\n    }\n  }\n\n  // Rescaling\n  var scale = null;\n\n  if (normalized) scale = order <= 1 ? null : 1 / (order * (order - 1));\n  else scale = graph.type === 'undirected' ? 0.5 : null;\n\n  if (scale !== null) {\n    graph.forEachEdge(function (edge) {\n      edgeCentralities[edge] *= scale;\n    });\n  }\n\n  if (assign) {\n    return graph.updateEachEdgeAttributes(function (edge, attr) {\n      attr[outputName] = edgeCentralities[edge];\n      return attr;\n    });\n  }\n\n  return edgeCentralities;\n}\n\n/**\n * Exporting.\n */\nvar edgeBetweennessCentrality = abstractEdgeBetweennessCentrality.bind(\n  null,\n  false\n);\nedgeBetweennessCentrality.assign = abstractEdgeBetweennessCentrality.bind(\n  null,\n  true\n);\n\nmodule.exports = edgeBetweennessCentrality;\n", "/**\n * Mnemonist SparseSet\n * ====================\n *\n * JavaScript sparse set implemented on top of byte arrays.\n *\n * [Reference]: https://research.swtch.com/sparse\n */\nvar Iterator = require('obliterator/iterator'),\n    getPointerArray = require('./utils/typed-arrays.js').getPointerArray;\n\n/**\n * SparseSet.\n *\n * @constructor\n */\nfunction SparseSet(length) {\n\n  var ByteArray = getPointerArray(length);\n\n  // Properties\n  this.size = 0;\n  this.length = length;\n  this.dense = new ByteArray(length);\n  this.sparse = new ByteArray(length);\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nSparseSet.prototype.clear = function() {\n  this.size = 0;\n};\n\n/**\n * Method used to check the existence of a member in the set.\n *\n * @param  {number} member - Member to test.\n * @return {SparseSet}\n */\nSparseSet.prototype.has = function(member) {\n  var index = this.sparse[member];\n\n  return (\n    index < this.size &&\n    this.dense[index] === member\n  );\n};\n\n/**\n * Method used to add a member to the set.\n *\n * @param  {number} member - Member to add.\n * @return {SparseSet}\n */\nSparseSet.prototype.add = function(member) {\n  var index = this.sparse[member];\n\n  if (index < this.size && this.dense[index] === member)\n    return this;\n\n  this.dense[this.size] = member;\n  this.sparse[member] = this.size;\n  this.size++;\n\n  return this;\n};\n\n/**\n * Method used to remove a member from the set.\n *\n * @param  {number} member - Member to delete.\n * @return {boolean}\n */\nSparseSet.prototype.delete = function(member) {\n  var index = this.sparse[member];\n\n  if (index >= this.size || this.dense[index] !== member)\n    return false;\n\n  index = this.dense[this.size - 1];\n  this.dense[this.sparse[member]] = index;\n  this.sparse[index] = this.sparse[member];\n  this.size--;\n\n  return true;\n};\n\n/**\n * Method used to iterate over the set's values.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nSparseSet.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var item;\n\n  for (var i = 0; i < this.size; i++) {\n    item = this.dense[i];\n\n    callback.call(scope, item, item);\n  }\n};\n\n/**\n * Method used to create an iterator over a set's values.\n *\n * @return {Iterator}\n */\nSparseSet.prototype.values = function() {\n  var size = this.size,\n      dense = this.dense,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i < size) {\n      var item = dense[i];\n      i++;\n\n      return {\n        value: item\n      };\n    }\n\n    return {\n      done: true\n    };\n  });\n};\n\n/**\n * Attaching the #.values method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  SparseSet.prototype[Symbol.iterator] = SparseSet.prototype.values;\n\n/**\n * Convenience known methods.\n */\nSparseSet.prototype.inspect = function() {\n  var proxy = new Set();\n\n  for (var i = 0; i < this.size; i++)\n    proxy.add(this.dense[i]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: SparseSet,\n    enumerable: false\n  });\n\n  proxy.length = this.length;\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  SparseSet.prototype[Symbol.for('nodejs.util.inspect.custom')] = SparseSet.prototype.inspect;\n\n/**\n * Exporting.\n */\nmodule.exports = SparseSet;\n", "/**\n * Graphology Closeness Centrality\n * ================================\n *\n * JavaScript implementation of the closeness centrality\n *\n * [References]:\n * https://en.wikipedia.org/wiki/Closeness_centrality\n *\n * Linton C. Freeman: Centrality in networks: I.\n * Conceptual clarification. Social Networks 1:215-239, 1979.\n * https://doi.org/10.1016/0378-8733(78)90021-7\n *\n * pg. 201 of Wasserman, S. and Faust, K.,\n * Social Network Analysis: Methods and Applications, 1994,\n * Cambridge University Press.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar resolveDefaults = require('graphology-utils/defaults');\nvar FixedDeque = require('mnemonist/fixed-deque');\nvar SparseSet = require('mnemonist/sparse-set');\nvar NeighborhoodIndex =\n  require('graphology-indices/neighborhood').NeighborhoodIndex;\n\n// TODO: can be computed for a single node\n// TODO: weighted\n// TODO: abstract the single source indexed shortest path in lib\n// TODO: what about self loops?\n// TODO: refactor a BFSQueue working on integer ranges in graphology-indices?\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  nodeCentralityAttribute: 'closenessCentrality',\n  wassermanFaust: false\n};\n\n/**\n * Helpers.\n */\nfunction IndexedBFS(graph) {\n  this.index = new NeighborhoodIndex(graph, 'inbound');\n  this.queue = new FixedDeque(Array, graph.order);\n  this.seen = new SparseSet(graph.order);\n}\n\nIndexedBFS.prototype.fromNode = function (i) {\n  var index = this.index;\n  var queue = this.queue;\n  var seen = this.seen;\n\n  seen.clear();\n  queue.clear();\n\n  seen.add(i);\n  queue.push([i, 0]);\n\n  var item, n, d, j, l, neighbor;\n\n  var total = 0;\n  var count = 0;\n\n  while (queue.size !== 0) {\n    item = queue.shift();\n    n = item[0];\n    d = item[1];\n\n    if (d !== 0) {\n      total += d;\n      count += 1;\n    }\n\n    l = index.starts[n + 1];\n\n    for (j = index.starts[n]; j < l; j++) {\n      neighbor = index.neighborhood[j];\n\n      if (seen.has(neighbor)) continue;\n\n      seen.add(neighbor);\n      queue.push([neighbor, d + 1]);\n    }\n  }\n\n  return [count, total];\n};\n\n/**\n * Abstract function computing the closeness centrality of a graph's nodes.\n *\n * @param  {boolean}  assign        - Should we assign the result to nodes.\n * @param  {Graph}    graph         - Target graph.\n * @param  {?object}  option        - Options:\n * @param  {?string}   nodeCentralityAttribute - Name of the centrality attribute to assign.\n * @param  {?boolean}  wassermanFaust - Whether to compute the Wasserman & Faust\n *                                      variant of the metric.\n * @return {object|undefined}\n */\nfunction abstractClosenessCentrality(assign, graph, options) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-metrics/centrality/closeness: the given graph is not a valid graphology instance.'\n    );\n\n  options = resolveDefaults(options, DEFAULTS);\n\n  var wassermanFaust = options.wassermanFaust;\n\n  var bfs = new IndexedBFS(graph);\n\n  var N = graph.order;\n\n  var i, result, count, total, closeness;\n\n  var mapping = new Float64Array(N);\n\n  for (i = 0; i < N; i++) {\n    result = bfs.fromNode(i);\n    count = result[0];\n    total = result[1];\n\n    closeness = 0;\n\n    if (total > 0 && N > 1) {\n      closeness = count / total;\n\n      if (wassermanFaust) {\n        closeness *= count / (N - 1);\n      }\n    }\n\n    mapping[i] = closeness;\n  }\n\n  if (assign) {\n    return bfs.index.assign(options.nodeCentralityAttribute, mapping);\n  }\n\n  return bfs.index.collect(mapping);\n}\n\n/**\n * Exporting.\n */\nvar closenessCentrality = abstractClosenessCentrality.bind(null, false);\nclosenessCentrality.assign = abstractClosenessCentrality.bind(null, true);\n\nmodule.exports = closenessCentrality;\n", "/**\n * Graphology Eigenvector Centrality\n * ==================================\n *\n * JavaScript implementation of the eigenvector centrality.\n *\n * [References]:\n * https://en.wikipedia.org/wiki/Eigenvector_centrality\n *\n * Phillip Bonacich. \"Power and Centrality: A Family of Measures.\"\n * American Journal of Sociology, 92(5):11701182, 1986\n * http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf\n *\n * Mark E. J. Newman.\n * Networks: An Introduct *\n * Oxford University Press, USA, 2010, pp. 169.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar resolveDefaults = require('graphology-utils/defaults');\nvar WeightedNeighborhoodIndex =\n  require('graphology-indices/neighborhood').WeightedNeighborhoodIndex;\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  nodeCentralityAttribute: 'eigenvectorCentrality',\n  getEdgeWeight: 'weight',\n  maxIterations: 100,\n  tolerance: 1e-6\n};\n\n/**\n * Helpers.\n */\nfunction safeVariadicHypot(x) {\n  var max = 0;\n  var s = 0;\n\n  for (var i = 0, l = x.length; i < l; i++) {\n    var n = Math.abs(x[i]);\n\n    if (n > max) {\n      s *= (max / n) * (max / n);\n      max = n;\n    }\n    s += n === 0 && max === 0 ? 0 : (n / max) * (n / max);\n  }\n\n  // NOTE: In case of numerical error we'll assume the norm is 1 in our case!\n  return max === Infinity ? 1 : max * Math.sqrt(s);\n}\n\n/**\n * Abstract function computing the eigenvector centrality of a graph's nodes.\n *\n * @param  {boolean}  assign        - Should we assign the result to nodes.\n * @param  {Graph}    graph         - Target graph.\n * @param  {?object}  option        - Options:\n * @param  {?string}    nodeCentralityAttribute - Name of the centrality attribute to assign.\n * @param  {?string}    getEdgeWeight - Name of the weight algorithm or getter function.\n * @param  {?number}    maxIterations - Maximum number of iterations to perform.\n * @param  {?number}    tolerance     - Error tolerance when checking for convergence.\n * @return {object|undefined}\n */\nfunction abstractEigenvectorCentrality(assign, graph, options) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-metrics/centrality/eigenvector: the given graph is not a valid graphology instance.'\n    );\n\n  options = resolveDefaults(options, DEFAULTS);\n\n  var maxIterations = options.maxIterations;\n  var tolerance = options.tolerance;\n\n  var N = graph.order;\n\n  var index = new WeightedNeighborhoodIndex(graph, options.getEdgeWeight);\n\n  var i, j, l, w;\n\n  var x = new Float64Array(graph.order);\n\n  // Initializing\n  for (i = 0; i < N; i++) {\n    x[i] = 1 / N;\n  }\n\n  // Power iterations\n  var iteration = 0;\n  var error = 0;\n  var neighbor, xLast, norm;\n  var converged = false;\n\n  while (iteration < maxIterations) {\n    xLast = x;\n    x = new Float64Array(xLast);\n\n    for (i = 0; i < N; i++) {\n      l = index.starts[i + 1];\n\n      for (j = index.starts[i]; j < l; j++) {\n        neighbor = index.neighborhood[j];\n        w = index.weights[j];\n        x[neighbor] += xLast[i] * w;\n      }\n    }\n\n    norm = safeVariadicHypot(x);\n\n    for (i = 0; i < N; i++) {\n      x[i] /= norm;\n    }\n\n    // Checking convergence\n    error = 0;\n\n    for (i = 0; i < N; i++) {\n      error += Math.abs(x[i] - xLast[i]);\n    }\n\n    if (error < N * tolerance) {\n      converged = true;\n      break;\n    }\n\n    iteration++;\n  }\n\n  if (!converged)\n    throw Error(\n      'graphology-metrics/centrality/eigenvector: failed to converge.'\n    );\n\n  if (assign) {\n    index.assign(options.nodeCentralityAttribute, x);\n    return;\n  }\n\n  return index.collect(x);\n}\n\n/**\n * Exporting.\n */\nvar eigenvectorCentrality = abstractEigenvectorCentrality.bind(null, false);\neigenvectorCentrality.assign = abstractEigenvectorCentrality.bind(null, true);\n\nmodule.exports = eigenvectorCentrality;\n", "/**\n * Graphology HITS Algorithm\n * ==========================\n *\n * Implementation of the HITS algorithm for the graphology specs.\n */\nvar resolveDefaults = require('graphology-utils/defaults');\nvar isGraph = require('graphology-utils/is-graph');\nvar createEdgeWeightGetter =\n  require('graphology-utils/getters').createEdgeWeightGetter;\n\n// TODO: optimize using NeighborhoodIndex\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  nodeAuthorityAttribute: 'authority',\n  nodeHubAttribute: 'hub',\n  getEdgeWeight: 'weight',\n  maxIterations: 100,\n  normalize: true,\n  tolerance: 1e-8\n};\n\n/**\n * Function returning an object with the given keys set to the given value.\n *\n * @param  {array}  keys  - Keys to set.\n * @param  {number} value - Value to set.\n * @return {object}       - The created object.\n */\nfunction dict(keys, value) {\n  var o = Object.create(null);\n\n  var i, l;\n\n  for (i = 0, l = keys.length; i < l; i++) o[keys[i]] = value;\n\n  return o;\n}\n\n/**\n * Function returning the sum of an object's values.\n *\n * @param  {object} o - Target object.\n * @return {number}   - The sum.\n */\nfunction sum(o) {\n  var nb = 0;\n\n  for (var k in o) nb += o[k];\n\n  return nb;\n}\n\n/**\n * HITS function taking a Graph instance & some options and returning a map\n * of nodes to their hubs & authorities.\n *\n * @param  {boolean} assign    - Should we assign the results as node attributes?\n * @param  {Graph}   graph     - A Graph instance.\n * @param  {object}  [options] - Options:\n * @param  {number}    [maxIterations] - Maximum number of iterations to perform.\n * @param  {boolean}   [normalize]     - Whether to normalize the results by the\n *                                       sum of all values.\n * @param  {number}    [tolerance]     - Error tolerance used to check\n *                                       convergence in power method iteration.\n */\nfunction hits(assign, graph, options) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-hits: the given graph is not a valid graphology instance.'\n    );\n\n  if (graph.multi)\n    throw new Error(\n      'graphology-hits: the HITS algorithm does not work with MultiGraphs.'\n    );\n\n  options = resolveDefaults(options, DEFAULTS);\n\n  var getEdgeWeight = createEdgeWeightGetter(options.getEdgeWeight).fromEntry;\n\n  // Variables\n  var order = graph.order;\n  var nodes = graph.nodes();\n  var edges;\n  var hubs = dict(nodes, 1 / order);\n  var weights = {};\n  var converged = false;\n  var lastHubs;\n  var authorities;\n\n  // Iteration variables\n  var node, neighbor, edge, iteration, maxAuthority, maxHub, error, S, i, j, m;\n\n  // Indexing weights\n  graph.forEachEdge(function (e, a, s, t, sa, ta, u) {\n    weights[e] = getEdgeWeight(e, a, s, t, sa, ta, u);\n  });\n\n  // Performing iterations\n  for (iteration = 0; iteration < options.maxIterations; iteration++) {\n    lastHubs = hubs;\n    hubs = dict(nodes, 0);\n    authorities = dict(nodes, 0);\n    maxHub = 0;\n    maxAuthority = 0;\n\n    // Iterating over nodes to update authorities\n    for (i = 0; i < order; i++) {\n      node = nodes[i];\n      edges = graph.outboundEdges(node);\n\n      // Iterating over neighbors\n      for (j = 0, m = edges.length; j < m; j++) {\n        edge = edges[j];\n        neighbor = graph.opposite(node, edge);\n\n        authorities[neighbor] += lastHubs[node] * weights[edge];\n\n        if (authorities[neighbor] > maxAuthority)\n          maxAuthority = authorities[neighbor];\n      }\n    }\n\n    // Iterating over nodes to update hubs\n    for (i = 0; i < order; i++) {\n      node = nodes[i];\n      edges = graph.outboundEdges(node);\n\n      for (j = 0, m = edges.length; j < m; j++) {\n        edge = edges[j];\n        neighbor = graph.opposite(node, edge);\n\n        hubs[node] += authorities[neighbor] * weights[edge];\n\n        if (hubs[neighbor] > maxHub) maxHub = hubs[neighbor];\n      }\n    }\n\n    // Normalizing\n    S = 1 / maxHub;\n\n    for (node in hubs) hubs[node] *= S;\n\n    S = 1 / maxAuthority;\n\n    for (node in authorities) authorities[node] *= S;\n\n    // Checking convergence\n    error = 0;\n\n    for (node in hubs) error += Math.abs(hubs[node] - lastHubs[node]);\n\n    if (error < options.tolerance) {\n      converged = true;\n      break;\n    }\n  }\n\n  if (!converged)\n    throw Error('graphology-metrics/centrality/hits: failed to converge.');\n\n  // Should we normalize the result?\n  if (options.normalize) {\n    S = 1 / sum(authorities);\n\n    for (node in authorities) authorities[node] *= S;\n\n    S = 1 / sum(hubs);\n\n    for (node in hubs) hubs[node] *= S;\n  }\n\n  // Should we assign the results to the graph?\n  if (assign) {\n    graph.updateEachNodeAttributes(\n      function (n, attr) {\n        attr[options.nodeAuthorityAttribute] = authorities[n];\n        attr[options.nodeHubAttribute] = hubs[n];\n\n        return attr;\n      },\n      {\n        attributes: [options.nodeAuthorityAttribute, options.nodeHubAttribute]\n      }\n    );\n\n    return;\n  }\n\n  return {hubs: hubs, authorities: authorities};\n}\n\n/**\n * Exporting.\n */\nvar main = hits.bind(null, false);\nmain.assign = hits.bind(null, true);\n\nmodule.exports = main;\n", "/**\n * Graphology Pagerank\n * ====================\n *\n * JavaScript implementation of the pagerank algorithm for graphology.\n *\n * [Reference]:\n * Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\n * The PageRank citation ranking: Bringing order to the Web. 1999\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar resolveDefaults = require('graphology-utils/defaults');\nvar WeightedNeighborhoodIndex =\n  require('graphology-indices/neighborhood').WeightedNeighborhoodIndex;\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  nodePagerankAttribute: 'pagerank',\n  getEdgeWeight: 'weight',\n  alpha: 0.85,\n  maxIterations: 100,\n  tolerance: 1e-6\n};\n\n/**\n * Abstract function applying the pagerank algorithm to the given graph.\n *\n * @param  {boolean}  assign        - Should we assign the result to nodes.\n * @param  {Graph}    graph         - Target graph.\n * @param  {?object}  option        - Options:\n * @param  {?object}    attributes  - Custom attribute names:\n * @param  {?string}      pagerank  - Name of the pagerank attribute to assign.\n * @param  {?string}      weight    - Name of the weight algorithm.\n * @param  {?number}  alpha         - Damping parameter.\n * @param  {?number}  maxIterations - Maximum number of iterations to perform.\n * @param  {?number}  tolerance     - Error tolerance when checking for convergence.\n * @param  {?boolean} weighted      - Should we use the graph's weights.\n * @return {object|undefined}\n */\nfunction abstractPagerank(assign, graph, options) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-metrics/centrality/pagerank: the given graph is not a valid graphology instance.'\n    );\n\n  options = resolveDefaults(options, DEFAULTS);\n\n  var alpha = options.alpha;\n  var maxIterations = options.maxIterations;\n  var tolerance = options.tolerance;\n\n  var pagerankAttribute = options.nodePagerankAttribute;\n\n  var N = graph.order;\n  var p = 1 / N;\n\n  var index = new WeightedNeighborhoodIndex(graph, options.getEdgeWeight);\n\n  var i, j, l, d;\n\n  var x = new Float64Array(graph.order);\n\n  // Normalizing edge weights & indexing dangling nodes\n  var normalizedEdgeWeights = new Float64Array(index.weights.length);\n  var danglingNodes = [];\n\n  for (i = 0; i < N; i++) {\n    x[i] = p;\n    l = index.starts[i + 1];\n    d = index.outDegrees[i];\n\n    if (d === 0) danglingNodes.push(i);\n\n    for (j = index.starts[i]; j < l; j++) {\n      normalizedEdgeWeights[j] = index.weights[j] / d;\n    }\n  }\n\n  // Power iterations\n  var iteration = 0;\n  var error = 0;\n  var dangleSum, neighbor, xLast;\n  var converged = false;\n\n  while (iteration < maxIterations) {\n    xLast = x;\n    x = new Float64Array(graph.order); // TODO: it should be possible to swap two arrays to avoid allocations (bench)\n\n    dangleSum = 0;\n\n    for (i = 0, l = danglingNodes.length; i < l; i++)\n      dangleSum += xLast[danglingNodes[i]];\n\n    dangleSum *= alpha;\n\n    for (i = 0; i < N; i++) {\n      l = index.starts[i + 1];\n\n      for (j = index.starts[i]; j < l; j++) {\n        neighbor = index.neighborhood[j];\n        x[neighbor] += alpha * xLast[i] * normalizedEdgeWeights[j];\n      }\n\n      x[i] += dangleSum * p + (1 - alpha) * p;\n    }\n\n    // Checking convergence\n    error = 0;\n\n    for (i = 0; i < N; i++) {\n      error += Math.abs(x[i] - xLast[i]);\n    }\n\n    if (error < N * tolerance) {\n      converged = true;\n      break;\n    }\n\n    iteration++;\n  }\n\n  if (!converged)\n    throw Error('graphology-metrics/centrality/pagerank: failed to converge.');\n\n  if (assign) {\n    index.assign(pagerankAttribute, x);\n    return;\n  }\n\n  return index.collect(x);\n}\n\n/**\n * Exporting.\n */\nvar pagerank = abstractPagerank.bind(null, false);\npagerank.assign = abstractPagerank.bind(null, true);\n\nmodule.exports = pagerank;\n", "/**\n * Graphology Metrics Centrality\n * ==============================\n *\n * Sub module endpoint.\n */\nvar degree = require('./degree.js');\n\nexports.betweenness = require('./betweenness.js');\nexports.edgeBetweenness = require('./edge-betweenness.js');\nexports.closeness = require('./closeness.js');\nexports.eigenvector = require('./eigenvector.js');\nexports.hits = require('./hits.js');\nexports.pagerank = require('./pagerank.js');\n\nexports.degree = degree.degreeCentrality;\nexports.inDegree = degree.inDegreeCentrality;\nexports.outDegree = degree.outDegreeCentrality;\n"],
  "mappings": "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",
  "names": []
}
